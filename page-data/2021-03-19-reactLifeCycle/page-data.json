{
    "componentChunkName": "component---src-components-post-template-tsx",
    "path": "/2021-03-19-reactLifeCycle/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<h2>React LIfecycle of Component</h2>\n<blockquote>\n<p>리액트 컴포넌트의 라이프 사이클에 대한 글</p>\n<p>현재는 클래스형을 많이 사용하지는 않는다고 하지만 그래도 알고 있어야 될 것 같아 정리한다.</p>\n</blockquote>\n<h5>먼저 클래스형과 함수형의 차이부터 알아보자!</h5>\n<ul>\n<li>클래스형</li>\n</ul>\n<pre class=\"grvsc-container solarized-light grvsc-mm-tuw09S\" data-language=\"react\" data-index=\"0\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">import React, {Component} from &#39;react&#39;;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">class App extends Component { //클래스로 선언하고 Component를 상속받아 사용해야 한다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  render() { //렌더 메소드가 반드시 필요하다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    const name = &#39;react&#39;;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    return &lt;div className=&quot;react&quot;&gt;{name}&lt;/div&gt;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">export default App;</span></span></code></pre>\n<ul>\n<li>함수형</li>\n</ul>\n<pre class=\"grvsc-container solarized-light grvsc-mm-tuw09S\" data-language=\"react\" data-index=\"1\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">import React from &#39;react&#39;;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">import &#39;./App.css&#39;;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">function App() {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  const name = &#39;react&#39;;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  return &lt;div className = &quot;react&quot;&gt;{name}&lt;/div&gt;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">export default App;</span></span></code></pre>\n<ul>\n<li>차이</li>\n</ul>\n<table>\n<thead>\n<tr>\n<th>클래스형</th>\n<th>함수형</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>state, lifeCycle 관련 기능 사용 가능</td>\n<td>state, lifeCycle 관련기능 사용 못했다.(hook으로 해결)</td>\n</tr>\n<tr>\n<td>메모리를 함수형보다는 더 씀</td>\n<td>메모리를 클래스형보다 덜 씀</td>\n</tr>\n<tr>\n<td>임의 메서드 정의 가능</td>\n<td>컴포넌트 선언이 편함</td>\n</tr>\n<tr>\n<td>Stateful 컴포넌트 : 로직과 상태를 컴포넌트 내에서 구현, 상대적으로 복잡한 UI</td>\n<td>Stateless 컴포넌트 : state를 사용하지 않고 단순하게 데이터(props)를 받아서 UI에 뿌려줌</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>클래스형 컴포넌트 예제</li>\n</ul>\n<pre class=\"grvsc-container solarized-light grvsc-mm-tuw09S\" data-language=\"react\" data-index=\"2\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">import React, { Component } from &#39;react&#39;;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">class Counter extends Component {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    //클래스형 컴포넌트에서는 클래스 내의 constructor 메서드에서 state의 초기값을 설정해줘야 함.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  constructor(props) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    super(props); //반드시 호출해줘야 함</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    this.state = {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">      number: 0</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    };</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  render() {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    const { number } = this.state; // state 를 조회할 때에는 this.state 로 조회합니다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    return (</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">      &lt;div&gt;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        &lt;h1&gt;{number}&lt;/h1&gt;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        &lt;button</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">          // onClick 을 통하여 버튼이 클릭됐을 때 호출 할 함수를 지정합니다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">          onClick={() =&gt; {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            // this.setState를 사용하여 state에 새로운 값을 넣을 수 있습니다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">            this.setState({ number: number + 1 });</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">          }}</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        &gt;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">          +1</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">        &lt;/button&gt;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">      &lt;/div&gt;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    );</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">export default Counter;</span></span></code></pre>\n<h3>리액트 컴포넌트 라이프사이클</h3>\n<ul>\n<li>\n<p>라이프사이클은 크게 세 부분으로 나뉘어진다. (마운트, 업데이트 , 언마운트)</p>\n</li>\n<li>\n<p>마운트 : DOM이 생성되고 웹 브라우저 상에 나타나는 것</p>\n</li>\n<li>\n<p>업데이트 : 컴포넌트가 업데이트 되는 경우는 네가지</p>\n<ul>\n<li>props가 바뀔 때</li>\n<li>state가 바뀔 때</li>\n<li>부모 컴포넌트가 리렌더링 될 때</li>\n<li>this.forceUpdate로 강제로 렌더링을 트리거 할 때</li>\n</ul>\n</li>\n<li>\n<p>언마운트</p>\n</li>\n</ul>\n<p><img src=\"https://i.imgur.com/cNfpEph.png\" alt=\"image\"></p>\n<p>출처: <a href=\"http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/</a></p>\n<h4>1. 마운트</h4>\n<pre class=\"grvsc-container solarized-light grvsc-mm-tuw09S\" data-language=\"react\" data-index=\"3\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    1. constructor</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    2. getDerivedStateFromProps</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    3. render</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    4. componentDidMount</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t1. constructor : 컴포넌트의 생성자 메서드, 컴포넌트가 만들어질 때 가장먼저 실행</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t리액트에서 생성자의 역할은 다음 두 가지가 있다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*        - this.state에 객체를 할당하여 지역 state를 초기화</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*        - 인스턴스에 이벤트 처리 메서드를 바인딩</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">constructor(props){</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    super(props);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    this.state = { counter: 0 };</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    this.handleClick = this.handleClick.bind(this);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">}</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">* \t2. getDerivedStateFromProps : props로 받아온 것을 state에 넣어주고 싶을 때 사용</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">* \t다른 생명주기 메서드와는 달리 static을 필요로 하고, 이 안에서는 this를 조회 할 수 없음</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">* \t컴포넌트가 처음 렌더링 되기 전에 호출되고, 그 이후 리렌더링 되기 전에 매번 실행 됨.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">* \t마운트 후에 다룰 업데이트에서도 props나 state가 바뀌면 이 함수가 실행 됨.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">static getDerivedStateFromProps(nextProps, prevState) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    console.log(&quot;getDerivedStateFromProps&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    if (nextProps.color !== prevState.color) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">      return { color: nextProps.color };</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    //여기서 특정 객체를 반환하게 되면, 해당 객체 안에 있는 내용들이 컴포넌트의 state로 설정 됨.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    //null로 반환 시 아무일도 안일어남</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    return null;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">//3. render : 컴포넌트를 렌더링 하는 메서드</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"> render() {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    const name = &#39;react&#39;;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    return &lt;div className=&quot;react&quot;&gt;{name}&lt;/div&gt;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t4. componentDidMount : 컴포넌트의 첫번째 렌더링이 마치고 나면 호출되는 메서드</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t이 메서드가 호출되는 시점에는 우리가 만든 컴포넌트가 화면에 나타나는 상태</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\tDOM을 사용해야하는 외부 라이브러리 연동을 하거나, axios, fetch 등을 통하여 요청하거나</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\tDOM의 속성을 읽거나 직접 변경</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span></code></pre>\n<h4>2. 업데이트</h4>\n<pre class=\"grvsc-container solarized-light grvsc-mm-tuw09S\" data-language=\"react\" data-index=\"4\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    getDerivedStateFromProps</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    shouldComponentUpdate</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    render</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    getSnapshotBeforeUpdate</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*    componentDidUpdate</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t1. getDerivedStateFromProps :  props 나 state 가 바뀌었을때도 이 메서드가 호출된다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t2. shouldComponentUpdate : 컴포넌트가 리렌더링 할지 말지를 결정하는 메서드</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t주로 최적화할 때 많이 사용한다고 한다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">shouldComponentUpdate(nextProps, nextState) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    console.log(&quot;shouldComponentUpdate&quot;, nextProps, nextState);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    // 숫자의 마지막 자리가 4면 리렌더링하지 않습니다</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    return nextState.number % 10 !== 4;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t3. render 생략</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t4. getSnapshotBeforeUpdate : 컴포넌트에 변화가 일어나기 직전의 DOM의 상태를 가져와서</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t특정 값을 반환하면 그 다음 발생하는 componentDidUpdate 함수에서 받아와서 사용을 할 수 있다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"> getSnapshotBeforeUpdate(prevProps, prevState) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    console.log(&quot;getSnapshotBeforeUpdate&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    if (prevProps.color !== this.props.color) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">      return this.myRef.style.color;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">     //반환한 값으로 그 다음 발생하는 componentDidUpdate 함수에서 받아와서 사용을 할 수 있다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    return null;</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">/*</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t5. componentDidUpdate : 리렌더링이 마치고, 화면에 우리가 원하는 변화가</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t모두 반영되고 난 뒤 호출되는 메서드</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*\t세 번째 파라미터로 4번의 getSnapshotBeforeUpdate에서 반환한 값을 조회할 수 있다.</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">*/</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"></span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">componentDidUpdate(prevProps, prevState, snapshot) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    console.log(&quot;componentDidUpdate&quot;, prevProps, prevState);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    if (snapshot) {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">      console.log(&quot;업데이트 되기 직전 색상: &quot;, snapshot);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    }</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span></code></pre>\n<ul>\n<li><a href=\"https://codesandbox.io/s/getsnapshotbeforeupdate-yeje-vpmle?fontsize=14&#x26;file=/src/ScrollBox.js:1293-1296\">https://codesandbox.io/s/getsnapshotbeforeupdate-yeje-vpmle?fontsize=14&#x26;file=/src/ScrollBox.js:1293-1296</a> - 사용사례 참고 (스크롤 위치 유지하기)</li>\n</ul>\n<h4>3. 언마운트</h4>\n<pre class=\"grvsc-container solarized-light grvsc-mm-tuw09S\" data-language=\"react\" data-index=\"5\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\">// componentWillUnmount : 컴포넌트가 화면에서 사라지기 전에 호출</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">// DOM에 직접 등록했었던 이벤트 제거, setTimeout과 같은 것이 있으면 clearTimeout을 통하여 제거</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\"> componentWillUnmount() {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    console.log(&quot;componentWillUnmount&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }</span></span></code></pre>\n<p>📕리액트 문서의 Hook Motivation 📕</p>\n<blockquote>\n<h3>Class은 사람과 기계를 혼동시킵니다.</h3>\n<p>Class가 코드의 재사용성과 코드 구성을 좀 더 어렵게 만들 뿐만 아니라, React를 배우는데 큰 진입장벽이라는 것을 알게 되었습니다. Javascript에서 어떻게 <code>this</code>가 작동하는지 알아야만 했고, 대부분의 다른 언어와는 다르게 작동합니다. 이벤트 핸들러가 등록되는 방법을 기억해야만 합니다. 불안정한 <a href=\"https://babeljs.io/docs/en/babel-plugin-transform-class-properties/\">문법 제안들</a>이 없다면, 코드는 매우 장황해집니다. 사람들은 props, state, 그리고 top-down 데이터 흐름을 완벽하게 이해할 수 있지만, 여전히 Class는 쉽지 않습니다. React 안에서의 함수와 Class 컴포넌트들을 구별하고 각 요소를 언제 사용하는지는 숙련된 React 개발자 사이에서도 의견이 일치하지 않습니다.</p>\n</blockquote>\n<blockquote>\n<p>이러한 문제를 해결하기 위해, <strong>Hook은 Class없이 React 기능들을 사용하는 방법을 알려줍니다.</strong> 개념적으로 React 컴포넌트는 항상 함수에 더 가깝습니다. Hook은 React의 정신을 희생하지 않고 함수를 받아들입니다. Hook은 명령형 코드로 해결책을 찾을 수 있게 해주며 복잡한 함수형 또는 반응형 프로그래밍 기술을 배우도록 요구하지 않습니다.</p>\n</blockquote>\n<h3>그래서 나온게 Hook!</h3>\n<ul>\n<li><code>this.state</code> -> <code>useState </code></li>\n<li><code>componentDidMount</code>, <code>componentDidUpdate</code>, <code>componentWillUnmount</code> -> <code>useEffect</code></li>\n</ul>\n<h3>💫useEffect!!</h3>\n<blockquote>\n<ol>\n<li>\n<p>컴포넌트가 마운트 됐을 때 (처음 나타났을 때)</p>\n</li>\n<li>\n<p>언마운트 됐을 때 (사라질 때)</p>\n</li>\n<li>\n<p>업데이트 될 때 (특정 props가 바뀔 때) <strong>특정 작업을 처리하는 Hook</strong></p>\n</li>\n</ol>\n</blockquote>\n<ol>\n<li>코드를 먼저 보자</li>\n</ol>\n<pre class=\"grvsc-container solarized-light grvsc-mm-tuw09S\" data-language=\"react\" data-index=\"6\"><code class=\"grvsc-code\"><span class=\"grvsc-line\"><span class=\"grvsc-source\"> useEffect(() =&gt; {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    console.log(&quot;컴포넌트가 화면에 나타남&quot;);</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    return () =&gt; {</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">      console.log(&quot;컴포넌트가 화면에서 사라짐&quot;); //cleanup함수</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">    };</span></span>\n<span class=\"grvsc-line\"><span class=\"grvsc-source\">  }, []);</span></span></code></pre>\n<ul>\n<li>\n<p><code>useEffect(함수, 의존배열(deps))</code> : <code>useEffect</code>의 첫 번째 파라미터에는 함수, 두 번째 파라미터에는 의존값이 들어있는 배열(deps) 를 넣는다.</p>\n</li>\n<li>\n<p>deps 의존배열</p>\n<ul>\n<li>빈 값<code>[]</code>이면 컴포넌트가 처음 나타날때만 <code>useEffect</code>에 등록한 함수가 호출된다.</li>\n<li>설정해주지 않으면 <code>useEffect(()=> {console.log('리렌더링')})</code>컴포넌트가 리렌더링 될 때만 함수가 호출된다.</li>\n</ul>\n</li>\n<li>\n<p><code>cleanup</code>함수 : <code>useEffect</code>에서는 반환하는 함수를 cleanup 함수라고 부른다. <code>useEffect</code>에 대한 뒷정리를 해주고, deps가 빈 값이면 컴포넌트가 사라질 때 <code>cleanup</code>함수가 호출</p>\n</li>\n<li>\n<p>콘솔 화면</p>\n</li>\n</ul>\n<p><img src=\"https://user-images.githubusercontent.com/51187540/112601602-fe046f80-8e55-11eb-9e43-c9fb515909a1.png\" alt=\"image\"></p>\n<p>컴포넌트 세 개가 마운트 될 때 <code>컴포넌트가 화면에 나타남</code>이 출력되고</p>\n<p><code>삭제 </code> 버튼을 눌렀을 때 <code>컴포넌트가 화면에서 사라짐</code>이 출력된다.</p>\n<ul>\n<li>\n<p>출처</p>\n<ul>\n<li>누구든지 하는 리액트 - <a href=\"https://velopert.com/3631\">https://velopert.com/3631</a></li>\n<li>모던리액트 - <a href=\"https://react.vlpt.us/basic/25-lifecycle.html\">https://react.vlpt.us/basic/25-lifecycle.html</a></li>\n<li><a href=\"https://ko.reactjs.org/docs/hooks-overview.html\">https://ko.reactjs.org/docs/hooks-overview.html</a></li>\n</ul>\n</li>\n</ul>\n<style class=\"grvsc-styles\">\n  .grvsc-container {\n    overflow: auto;\n    position: relative;\n    -webkit-overflow-scrolling: touch;\n    padding-top: 1rem;\n    padding-top: var(--grvsc-padding-top, var(--grvsc-padding-v, 1rem));\n    padding-bottom: 1rem;\n    padding-bottom: var(--grvsc-padding-bottom, var(--grvsc-padding-v, 1rem));\n    border-radius: 8px;\n    border-radius: var(--grvsc-border-radius, 8px);\n    font-feature-settings: normal;\n    line-height: 1.4;\n  }\n  \n  .grvsc-code {\n    display: table;\n  }\n  \n  .grvsc-line {\n    display: table-row;\n    box-sizing: border-box;\n    width: 100%;\n    position: relative;\n  }\n  \n  .grvsc-line > * {\n    position: relative;\n  }\n  \n  .grvsc-gutter-pad {\n    display: table-cell;\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  .grvsc-gutter {\n    display: table-cell;\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter::before {\n    content: attr(data-content);\n  }\n  \n  .grvsc-source {\n    display: table-cell;\n    padding-left: 1.5rem;\n    padding-left: var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem));\n    padding-right: 1.5rem;\n    padding-right: var(--grvsc-padding-right, var(--grvsc-padding-h, 1.5rem));\n  }\n  \n  .grvsc-source:empty::after {\n    content: ' ';\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    user-select: none;\n  }\n  \n  .grvsc-gutter + .grvsc-source {\n    padding-left: 0.75rem;\n    padding-left: calc(var(--grvsc-padding-left, var(--grvsc-padding-h, 1.5rem)) / 2);\n  }\n  \n  /* Line transformer styles */\n  \n  .grvsc-has-line-highlighting > .grvsc-code > .grvsc-line::before {\n    content: ' ';\n    position: absolute;\n    width: 100%;\n  }\n  \n  .grvsc-line-diff-add::before {\n    background-color: var(--grvsc-line-diff-add-background-color, rgba(0, 255, 60, 0.2));\n  }\n  \n  .grvsc-line-diff-del::before {\n    background-color: var(--grvsc-line-diff-del-background-color, rgba(255, 0, 20, 0.2));\n  }\n  \n  .grvsc-line-number {\n    padding: 0 2px;\n    text-align: right;\n    opacity: 0.7;\n  }\n  \n  .solarized-light { background-color: #FDF6E3; }\n  .solarized-light .grvsc-line-highlighted::before {\n    background-color: var(--grvsc-line-highlighted-background-color, rgba(0, 0, 0, 0.05));\n    box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(0, 0, 0, 0.2));\n  }\n  \n  /* Monokai Dimmed */\n  @media (prefers-color-scheme: dark) {\n    .grvsc-mm-tuw09S {\n      background-color: #1e1e1e;\n      color: #c5c8c6;\n    }\n    .grvsc-mm-tuw09S .grvsc-line-highlighted::before {\n      background-color: var(--grvsc-line-highlighted-background-color, rgba(255, 255, 255, 0.1));\n      box-shadow: inset var(--grvsc-line-highlighted-border-width, 4px) 0 0 0 var(--grvsc-line-highlighted-border-color, rgba(255, 255, 255, 0.5));\n    }\n  }\n</style>","frontmatter":{"title":"React LIfecycle of Component"},"fields":{"slug":"/2021-03-19-reactLifeCycle/"}}}]}},"pageContext":{"slug":"/2021-03-19-reactLifeCycle/"}},
    "staticQueryHashes": ["290286666"]}